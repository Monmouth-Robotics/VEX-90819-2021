#include "motion/purePursuit/purePursuitOld.h"

using namespace std;
double WHEEL_DIAMETER2 = 2.75;

PositionAlg position;

//Create a task to keep track of the robot's position and heading
pros::Task positionController(position.calcPosition, NULL, "Position Tracker");

//Creates instance of indexer class to use indexing functions
Indexing indexer;

//Create a task to automate the motion of the stacks when balls enter
pros::Task indexController(indexer.indexingTask, NULL, "Ball Tracker");

/**
 * Creates a path of closely-spaced waypoints between two points
 * 
 * Parameters:
 * initX: starting x-coordinate
 * initY: starting y-coordinate
 * finalX: ending x-coordinate
 * finalY: ending y-coordinate
 * spacing: # of inches in between each waypoint
 */
vector<vector<double>> generateLinearPath(double initX, double initY, double finalX, double finalY, double spacing)
{
    vector<vector<double>> pointsList = {{0.0}};
    pointsList = {};

    //Finds the vector drawn from the start point to the end point
    vector<double> changeVector = {finalX - initX, finalY - initY};

    //Uses Pythagorean theorem to calculate magnitude of changeVector
    double magnitude = sqrt(pow(changeVector[0], 2) + pow(changeVector[1], 2));

    //Calculates the number of waypoints that need to be drawn
    double numPoints = ceil(magnitude / spacing);

    //Find the unit vector and multiply by spacing
    changeVector[0] = changeVector[0] * spacing / magnitude;
    changeVector[1] = changeVector[1] * spacing / magnitude;

    //Traverse through each point and save each point into vector
    for (int i = 0; i < numPoints; i++)
    {
        vector<double> newVector = {initX + changeVector[0] * i, initY + changeVector[1] * i};
        pointsList.push_back(newVector);
    }

    //Add the ending point to the list
    vector<double> finalVector{finalX, finalY};
    pointsList.push_back(finalVector);

    return pointsList;
}

/**
 * Calculates the distance traveled when robot is at each point
 */
vector<double> calculateDistance(vector<vector<double>> pointsList)
{
    //Initialize distance list as vector with the first value as 0.0
    vector<double> distanceList = {0.0};
    distanceList = {};
    distanceList.push_back(0.0);

    //Traverse through pointsList and calculate the total distance traveled on the path up to the current point
    for (int i = 1; i < pointsList.size(); i++)
    {
        //Calculate the distance between each pair of consecutive points and adds it to previous value
        distanceList.push_back(distanceList[i - 1] + sqrt(pow((pointsList[i][0] - pointsList[i - 1][0]), 2) + pow((pointsList[i][1] - pointsList[i - 1][1]), 2)));
    }

    return distanceList;
}

/**
 * Calculates curvature along every point on the path
 */
vector<double> calculateCurve(vector<vector<double>> pointsList)
{
    //Initialize curve list as vector with the first value as 0.0
    vector<double> curveList = {0.0};
    curveList = {};
    curveList.push_back(0.0);

    //Calculate curvature at each point excluding the first and last points
    for (int i = 1; i < pointsList.size() - 1; i++)
    {
        //Gets the x-coordinates of the current point and previous point
        double x1 = pointsList[i][0];
        double x2 = pointsList[i - 1][0];

        //Prevents error when dividing by (x1-x2)
        if (x1 == x2)
        {
            x1 += 0.001;
        }

        //Gets the x-coordinate of the next point
        double x3 = pointsList[i + 1][0];

        //Gets the y-coordinate of the current, previous, and next points
        double y1 = pointsList[i][1];
        double y2 = pointsList[i - 1][1];
        double y3 = pointsList[i + 1][1];

        //Intermediate constants used for calculations
        double k1 = 0.5 * (pow(x1, 2) + pow(y1, 2) - pow(x2, 2) - pow(y2, 2)) / (x1 - x2);
        double k2 = (y1 - y2) / (x1 - x2);
        double b = 0.5 * (pow(x2, 2) - 2 * x2 * k1 + pow(y2, 2) - pow(x3, 2) + 2 * x3 * k1 - pow(y3, 2)) / (x3 * k2 - y3 + y2 - x2 * k2);
        double a = k1 - k2 * b;

        //Push curvature value to vector
        curveList.push_back(1 / sqrt(pow(x1 - a, 2) + pow(y1 - b, 2)));
    }

    //Add curvature at last point as 0.0
    curveList.push_back(0.0);
    return curveList;
}

/**
 * Smooths out the path created by generateLinearPath()
 *
 * Parameters:
 * pointsList: list of points generated by generateLinearPath()
 * a: weight data (works best when set to 1-b)
 * b: weight of smoothing; larger b results in smoother path (a value between 0.75 and 0.98 works best)
 * tolerance: max allowable change value (works best when set to 0.001)
 */
vector<vector<double>> smooth(vector<vector<double>> pointsList, double a, double b, double tolerance)
{
    //Copy vector
    vector<vector<double>> newPointsList = pointsList;

    double change = tolerance;

    //Loops until change is within the acceptable tolerance
    while (change >= tolerance)
    {
        change = 0.0;

        //Loops through all points
        for (int i = 1; i < pointsList.size() - 1; i++)
        {
            //Loops through x and y coordinates for each point
            for (int j = 0; j < pointsList[i].size(); j++)
            {
                //Creates an auxiliary variable for manipulation
                double aux = newPointsList[i][j];

                //Creates new point based on weight data and weight of smoothing
                newPointsList[i][j] += a * (pointsList[i][j] - newPointsList[i][j]) + b * (newPointsList[i - 1][j] + newPointsList[i + 1][j] - (2.0 * newPointsList[i][j]));

                //Updates change based on new point
                change += abs(aux - newPointsList[i][j]);
            }
        }
    }
    return newPointsList;
}

/**
 * Calculates the robot's velocity at each point
 * 
 * Parameters:
 * pointsList: list of points after smoothing
 * curveList: list of curvature values at each point
 * maxVelocity: the maximum velocity at any point during the path
 * maxAccel: the maximum acceleration at any point during the path
 * turnConstant: defines how much to slow down at curves (value should be between 1.0 and 5.0)
 */
vector<double> calculateVelocity(vector<vector<double>> pointsList, vector<double> curveList, double maxVelocity, double maxAccel, double turnConstant)
{
    //Initialize max velocity list as empty vector
    vector<double> maxVelList = {0.0};
    maxVelList = {};

    //Calculate max velocity at each individual point
    for (int i = 0; i < curveList.size(); i++)
    {
        //Prevents divide by 0 error
        if (curveList[i] == 0.0)
        {
            curveList[i] = 0.001;
        }

        //Adds max velocity based on curvature, turnConstant, and maxVelocity, defined by parameters
        maxVelList.push_back(min(maxVelocity, (turnConstant / curveList[i])));
    }

    //Initialize target velocity list as vector with first value as 0.0
    vector<double> targetVelList = {0};
    targetVelList = {};
    targetVelList.push_back(0.0);

    //Set initial value to 0.0
    double prevVel = 0.0;

    //Calculate target velocity at each individual point
    for (int i = 1; i < maxVelList.size(); i++)
    {
        //Calculates new velocity based on previous velocity and limits set by parameters
        prevVel = sqrt(pow(prevVel, 2) + 2 * maxAccel * 0.0254 * sqrt(pow((pointsList[i][0] - pointsList[i - 1][0]), 2) + pow((pointsList[i][1] - pointsList[i - 1][1]), 2)));

        //Verifies that the value does not exceed max limit
        if (prevVel > maxVelList[i])
        {
            prevVel = maxVelList[i];
        }

        targetVelList.push_back(prevVel);
    }

    //Initialize actual velocity list as vector with all values set to 0.0 and the same size as max velocity list
    vector<double> velList(maxVelList.size(), 0.0);

    //Set initial value to 0.0
    double previousVel = 0.0;

    //Calculate actual velocity at each individual point
    for (int i = maxVelList.size() - 2; i >= 0; i--)
    {

        //Calculates distance between two consecutive points
        double distance = sqrt(pow((pointsList[i + 1][0] - pointsList[i][0]), 2) + pow((pointsList[i + 1][1] - pointsList[i][1]), 2));

        //Convert distance from inches to meters
        distance = distance * 0.0254;

        //Calculates new velocity based on max limit set by parameters
        previousVel = min(targetVelList[i], sqrt(pow(previousVel, 2) + 2 * maxAccel * distance));

        velList[i] = previousVel;
    }

    return velList;
}

//Calculates dot product of two vectors
double dot(vector<double> a, vector<double> b)
{
    return a[0] * b[0] + a[1] * b[1];
}

/**
 * Calculates the lookahead point at each point along the path
 *
 * Parameters:
 * x: current robot x-value
 * y: current robot y-value
 * pointsList: list of points after smoothing
 * closestPoint: index of the closest waypoint to the robot's current position
 * lookAheadPointsNum: # of lookahead points to start with
 * spacing: # of inches in between each waypoint
 */
vector<double> findLookAheadPoint(double x, double y, vector<vector<double>> pointsList, int closestPoint, int lookAheadPointsNum, double spacing)
{
    //Starting point of the line segment
    vector<double> E = pointsList[closestPoint];

    //End point of the line segment
    vector<double> L = pointsList[closestPoint + lookAheadPointsNum];

    //Center of the drawn circle, representing the robot position
    vector<double> C = {x, y};

    //Direction vector from starting point to ending point
    vector<double> d = {L[0] - E[0], L[1] - E[1]};

    //Vector drawn from center of robot to starting point
    vector<double> f = {E[0] - C[0], E[1] - C[1]};

    //Represents the lookahead distance
    double r = spacing * lookAheadPointsNum;

    //Determines number of intersections between circle around robot and path
    double a = dot(d, d);
    double b = 2 * dot(f, d);
    double c = dot(f, f) - r * r;
    double discriminant = b * b - 4 * a * c;

    //Represents no intersection
    if (discriminant < 0)
    {
        //If the current lookahead point is not the last point, it can expand its search radius
        if (closestPoint != pointsList.size() - lookAheadPointsNum - 1)
        {
            //Recursive function with a greater number of lookahead points
            return findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum + 1, spacing);
        }
        else
        {
            //Returns the last point in the list
            return pointsList[pointsList.size() - 1];
        }
    }
    else
    {
        //Find points of intersection at t1 and t2
        double t1 = (-b - sqrt(discriminant)) / (2 * a);
        double t2 = (-b + sqrt(discriminant)) / (2 * a);

        //Verifies that the lookahead point is ahead of the current point in the motion
        if (t1 >= 0 && t1 <= 1)
        {
            return {E[0] + t1 * d[0], E[1] + t1 * d[1]};
        }
        else if (t2 >= 0 && t2 <= 1)
        {
            return {E[0] + t2 * d[0], E[1] + t2 * d[1]};
        }
        //Expands search radius if both points found are behind the current point in the motion
        else
        {
            if (closestPoint != pointsList.size() - lookAheadPointsNum - 1)
            {
                //Recursive function with a greater number of lookahead points
                return findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum + 1, spacing);
            }
            else
            {
                //Returns the last point in the list
                return pointsList[pointsList.size() - 1];
            }
        }
    }
}

/**
 * Finds curvature between current position and lookahead point when moving forwards
 */
double findCurvature(vector<double> lookAheadPoint, double Rx, double Ry, double kC)
{
    //Calculates robot heading shifted on global grid for robot moving forwards
    double angle = (M_PI / 2 - position.getTheta());

    //Calculates robot line in form Ax+By+C=0, assuming B=1
    double a = -1 * tan(angle);
    double c = tan(angle) * Rx - Ry;

    //Calculate distance between lookahead point and robot line
    double x = abs(a * lookAheadPoint[0] + lookAheadPoint[1] + c) / sqrt(pow(a, 2) + 1);

    //Calculates sign of curvature (right is positive, left is negative)
    double side = (sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry)) / abs(sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry));

    //Calculate curvature between lookahead point and current robot position
    double curvature = (2 * x) / (pow((lookAheadPoint[0] - Rx), 2) + pow((lookAheadPoint[1] - Ry), 2));

    //Return signed value of curvature
    return curvature * side * kC;
}

/**
 * Finds curvature between current position and lookahead point when moving backwards
 */
double findCurvatureBackwards(vector<double> lookAheadPoint, double Rx, double Ry, double kC)
{
    //Calculates robot heading shifted on global grid for robot moving backwards
    double angle = int(M_PI / 2 - position.getTheta() + 180) % 360;

    //Calculates robot line in form Ax+By+C=0, assuming B=1
    double a = -1 * tan(angle);
    double c = tan(angle) * Rx - Ry;

    //Calculate distance between lookahead point and robot line
    double x = abs(a * lookAheadPoint[0] + lookAheadPoint[1] + c) / sqrt(pow(a, 2) + 1);

    //Calculates sign of curvature (right is positive, left is negative)
    double side = (sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry)) / abs(sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry));

    //Calculate curvature between lookahead point and current robot position
    double curvature = (2 * x) / (pow((lookAheadPoint[0] - Rx), 2) + pow((lookAheadPoint[1] - Ry), 2));

    //Return signed value of curvature
    return curvature * side * kC;
}

/**
 * Finds curvature between current position and lookahead point when strafing left
 */
double findCurvatureLeft(vector<double> lookAheadPoint, double Rx, double Ry, double kC)
{
    //Calculates robot heading shifted on global grid for robot strafing left
    double angle = int(M_PI / 2 - position.getTheta() + 270) % 360;

    //Calculates robot line in form Ax+By+C=0, assuming B=1
    double a = -1 * tan(angle);
    double c = tan(angle) * Rx - Ry;

    //Calculate distance between lookahead point and robot line
    double x = abs(a * lookAheadPoint[0] + lookAheadPoint[1] + c) / sqrt(pow(a, 2) + 1);

    //Calculates sign of curvature (right is positive, left is negative)
    double side = (sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry)) / abs(sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry));

    //Calculate curvature between lookahead point and current robot position
    double curvature = (2 * x) / (pow((lookAheadPoint[0] - Rx), 2) + pow((lookAheadPoint[1] - Ry), 2));

    //Return signed value of curvature
    return curvature * side * kC;
}

/**
 * Finds curvature between current position and lookahead point when strafing right
 */
double findCurvatureRight(vector<double> lookAheadPoint, double Rx, double Ry, double kC)
{
    //Calculates robot heading shifted on global grid for robot strafing right
    double angle = int(M_PI / 2 - position.getTheta() + 90) % 360;

    //Calculates robot line in form Ax+By+C=0, assuming B=1
    double a = -1 * tan(angle);
    double c = tan(angle) * Rx - Ry;

    //Calculate distance between lookahead point and robot line
    double x = abs(a * lookAheadPoint[0] + lookAheadPoint[1] + c) / sqrt(pow(a, 2) + 1);

    //Calculates sign of curvature (right is positive, left is negative)
    double side = (sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry)) / abs(sin(angle) * (lookAheadPoint[0] - Rx) - cos(angle) * (lookAheadPoint[1] - Ry));

    //Calculate curvature between lookahead point and current robot position
    double curvature = (2 * x) / (pow((lookAheadPoint[0] - Rx), 2) + pow((lookAheadPoint[1] - Ry), 2));

    //Return signed value of curvature
    return curvature * side * kC;
}

/**
 * Finds acceleration limited target velocity
 *
 * Parameters:
 * velocity: target velocity
 * maxAccel: the maximum acceleration at any point during the path
 * prevVel: current actual velocity
 */
vector<double> rateLimit(double velocity, double maxAccel, double prevVel)
{
    //Calculates maximum amount of movement allowed by acceleration
    double maxChange = 0.01 * maxAccel;

    double newVel = prevVel;
    double accel;

    //Checks to make sure that the change in acceleration doesn't exceed the max allowable change
    if (-1 * maxChange > (velocity - newVel))
    {
        newVel += -1 * maxChange;
        accel = -1 * maxChange;
    }
    else if (maxChange < (velocity - newVel))
    {
        newVel += maxChange;
        accel = maxChange;
    }
    else
    {
        newVel += (velocity - newVel);
        accel = velocity - newVel;
    }

    return {newVel, accel};
}

/**
 * Converts value from m/s to rpm
 */
double convertToRPM(double value)
{
    return value / (2 * M_PI * WHEEL_DIAMETER2 * 2.54) * (100 * 2 * 60.0);
}

/**
 * Converts value from m/s to rpm
 */
double convertToRPM(int value)
{
    return value / (2 * M_PI * WHEEL_DIAMETER2 * 2.54) * (100 * 2 * 60.0);
}

/**
 * Converts value from rpm to m/s
 */
double convertToMeters(double value)
{
    return value * (2 * M_PI * WHEEL_DIAMETER2 * 2.54) / (100 * 2 * 60.0);
}

/**
 * Converts value from rpm to m/s
 */
double convertToMeters(int value)
{

    return value * (2 * M_PI * WHEEL_DIAMETER2 * 2.54) / (100 * 2 * 60.0);
}

/**
 * Returns acceleration limited target left and right wheel velocities
 * 
 * Parameters:
 * curvature: curvature at current point
 * trackWidth: width from left wheels to right wheels on robot in inches (due to turning scrub might be higher than actual width)
 * velocity: target velocity
 * maxAccel: maximum acceleration robot is allowed to reach during movement in m/s^2
 * prevVel: current actual velocity
 */
vector<double> findVelocities(double curvature, double trackWidth, double velocity, double maxAccel, double prevVel)
{
    //Gets acceleration limited target velocity and acceleration
    vector<double> vel = rateLimit(velocity, maxAccel, prevVel);

    //Calculates and returns left and right wheel velocities
    return {vel[0] * (2 + curvature * trackWidth) / 2, vel[0] * (2 - curvature * trackWidth) / 2, vel[0], vel[1]};
}

/**
 * Moves forward using pure pursuit algorithm
 * 
 * Parameters:
 * initPoints: list of all points in motion
 * spacing: distance between points in inches
 * smoothVal1: value 1 for smoothing (should be around 1 - smoothVal2)
 * smoothVal2: value 2 for smoothing (should be a value between 0.75 and 0.98)
 * smoothTolerance: acceptable tolerance for smoothing (should be around 0.001)
 * maxVelocity: maximum speed robot is allowed to reach during movement in m/s
 * maxAccel: maximum acceleration robot is allowed to reach during movement in m/s^2
 * turnConstant: turn constant (should be between 1.0 and 5.0)
 * lookAheadPointsNum: number of points to look ahead
 * trackWidth: width from left wheels to right wheels on robot in inches (due to turning scrub might be higher than actual width)
 * Kv: velocity constant (should be around 1/maxVelocity)
 * Ka: acceleration constant (should be around 0.002)
 * Kp: proportional constant (starts at 0.01, increasing will make velocities more accurate but more jittery)
 * Kc: curvature constant
 */
void ppMoveForward(vector<vector<double>> initPoints, double spacing, double smoothVal1, double smoothVal2, double smoothTolerance, double maxVelocity, double maxAccel, double turnConstant, int lookAheadPointsNum, double trackWidth, double Kv, double Ka, double Kp, double Kc)
{
    //Initialize points list as an empty vector
    vector<vector<double>> pointsList = {{0.0}};
    pointsList = {};

    //Invalid call if no points are defined
    if (initPoints.size() == 0)
    {
        return;
    }

    //Generates path from current robot position to provided coordinate
    else if (initPoints.size() == 1)
    {
        pointsList = generateLinearPath(position.getPosition()[0], position.getPosition()[1], initPoints[0][0], initPoints[0][1], spacing);
    }

    //Generates path between each pair of consecutive points
    else
    {
        pointsList = generateLinearPath(initPoints[0][0], initPoints[0][1], initPoints[1][0], initPoints[1][1], spacing);
        if (initPoints.size() > 2)
        {
            for (int i = 1; i < initPoints.size() - 1; i++)
            {
                vector<vector<double>> pointsList2 = generateLinearPath(initPoints[i][0], initPoints[i][1], initPoints[i + 1][0], initPoints[i + 1][1], spacing);

                //Inserts each subsequent list at the end of the original
                pointsList.insert(pointsList.end(), pointsList2.begin(), pointsList2.end());
            }

            //Smooths entire points list
            pointsList = smooth(pointsList, smoothVal1, smoothVal2, smoothTolerance);
        }
    }

    //Calculate curvature along every point on the path
    vector<double> curveList = calculateCurve(pointsList);

    //Calculate velocity along every point on the path
    vector<double> velList = calculateVelocity(pointsList, curveList, maxVelocity, maxAccel, turnConstant);

    //Closest point starts as the second point in the list
    int closestPoint = 1;

    //Robot starts at rest with a velocity of 0.0 on each wheel
    vector<double> velocities = {0.0, 0.0};

    //Moves the robot until final position is reached
    while (true)
    {
        //Pulls the current robot coordinates
        double x = position.getPosition()[0];
        double y = position.getPosition()[1];

        //Initialize lookahead point as empty vector
        vector<double> lookAheadPoint = {0.0};
        lookAheadPoint = {};

        //Calculate distance between closest point and current robot position
        double smallestDistance = sqrt(pow((pointsList[closestPoint][0] - x), 2) + pow((pointsList[closestPoint][1] - y), 2));

        //Traverse through every point to find the closest point to the robot
        //For loop starts at closestPoint+1 to avoid traveling backwards
        for (int i = closestPoint + 1; i < pointsList.size(); i++)
        {
            //Calculates distance between current robot and each point after closest point
            double newDistance = sqrt(pow((pointsList[i][0] - x), 2) + pow((pointsList[i][1] - y), 2));

            //If the new distance is smaller than the smallest distance, replace smallest distance value with the new distance
            if (smallestDistance > newDistance)
            {
                smallestDistance = newDistance;

                //Change closest point to the new closest point
                closestPoint = i;
            }
        }

        //Calculate lookahead point if the last point is not within the default search radius
        if (closestPoint < pointsList.size() - 1 - lookAheadPointsNum)
        {
            lookAheadPoint = findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum, spacing);
        }

        //Use last point as lookahead point if the last point is within the default search radius
        else
        {
            lookAheadPoint = pointsList[pointsList.size() - 1];
        }

        //Exits loop if lookahead point and closest point align with the last point of the path
        if (lookAheadPoint[0] == pointsList[pointsList.size() - 1][0] && lookAheadPoint[1] == pointsList[pointsList.size() - 1][1] && (closestPoint == pointsList.size() - 1))
        {
            break;
        }

        //Calculate curvature between current position and lookahead point
        double curvature = findCurvature(lookAheadPoint, x, y, Kc);

        //Gets target left wheel speed, right wheel speed, velocity, and acceleration
        velocities = findVelocities(curvature, trackWidth, velList[closestPoint], maxAccel, velocities[2]);

        //Calculate feedforward and feedbackward values for the left and right wheels
        double leftFF = Kv * velocities[0] + Ka * (velocities[3]);
        double rightFF = Kv * velocities[1] + Ka * (velocities[3]);
        double leftFB = Kp * (velocities[0] - (convertToMeters(leftFrontMotor.get_actual_velocity() + leftBackMotor.get_actual_velocity()) / 2.0));
        double rightFB = Kp * (velocities[1] - (convertToMeters(rightFrontMotor.get_actual_velocity() + rightBackMotor.get_actual_velocity()) / 2.0));

        //Calculates motor velocities and moves the motors based on the feedforward and feedbackward values
        leftFrontMotor = convertToRPM(leftFF + leftFB) * 127.0 / 200;
        leftBackMotor = convertToRPM(leftFF + leftFB) * 127.0 / 200;
        rightFrontMotor = convertToRPM(rightFF + rightFB) * 127.0 / 200;
        rightBackMotor = convertToRPM(rightFF + rightFB) * 127.0 / 200;

        pros::delay(10);
    }

    //Stops all motors once robot reaches the endpoint
    leftFrontMotor = 0;
    leftBackMotor = 0;
    rightFrontMotor = 0;
    rightBackMotor = 0;
}

/**
 * Moves backward using pure pursuit algorithm
 * 
 * Parameters:
 * initPoints: list of all points in motion
 * spacing: distance between points in inches
 * smoothVal1: value 1 for smoothing (should be around 1 - smoothVal2)
 * smoothVal2: value 2 for smoothing (should be a value between 0.75 and 0.98)
 * smoothTolerance: acceptable tolerance for smoothing (should be around 0.001)
 * maxVelocity: maximum speed robot is allowed to reach during movement in m/s
 * maxAccel: maximum acceleration robot is allowed to reach during movement in m/s^2
 * turnConstant: turn constant (should be between 1.0 and 5.0)
 * lookAheadPointsNum: number of points to look ahead
 * trackWidth: width from left wheels to right wheels on robot in inches (due to turning scrub might be higher than actual width)
 * Kv: velocity constant (should be around 1/maxVelocity)
 * Ka: acceleration constant (should be around 0.002)
 * Kp: proportional constant (starts at 0.01, increasing will make velocities more accurate but more jittery)
 * Kc: curvature constant
 */
void ppMoveBackward(vector<vector<double>> initPoints, double spacing, double smoothVal1, double smoothVal2, double smoothTolerance, double maxVelocity, double maxAccel, double turnConstant, int lookAheadPointsNum, double trackWidth, double Kv, double Ka, double Kp, double Kc)
{
    //Initialize points list as an empty vector
    vector<vector<double>> pointsList = {{0.0}};
    pointsList = {};

    //Invalid call if no points are defined
    if (initPoints.size() == 0)
    {
        return;
    }

    //Generates path from current robot position to provided coordinate
    else if (initPoints.size() == 1)
    {
        pointsList = generateLinearPath(position.getPosition()[0], position.getPosition()[1], initPoints[0][0], initPoints[0][1], spacing);
    }

    //Generates path between each pair of consecutive points
    else
    {
        pointsList = generateLinearPath(initPoints[0][0], initPoints[0][1], initPoints[1][0], initPoints[1][1], spacing);
        if (initPoints.size() > 2)
        {
            for (int i = 1; i < initPoints.size() - 1; i++)
            {
                vector<vector<double>> pointsList2 = generateLinearPath(initPoints[i][0], initPoints[i][1], initPoints[i + 1][0], initPoints[i + 1][1], spacing);

                //Inserts each subsequent list at the end of the original
                pointsList.insert(pointsList.end(), pointsList2.begin(), pointsList2.end());
            }

            //Smooths entire points list
            pointsList = smooth(pointsList, smoothVal1, smoothVal2, smoothTolerance);
        }
    }

    //Calculate curvature along every point on the path
    vector<double> curveList = calculateCurve(pointsList);

    //Calculate velocity along every point on the path
    vector<double> velList = calculateVelocity(pointsList, curveList, maxVelocity, maxAccel, turnConstant);

    //Closest point starts as the second point in the list
    int closestPoint = 1;

    //Robot starts at rest with a velocity of 0.0 on each wheel
    vector<double> velocities = {0.0, 0.0};

    //Moves the robot until final position is reached
    while (true)
    {
        //Pulls the current robot coordinates
        double x = position.getPosition()[0];
        double y = position.getPosition()[1];

        //Initialize lookahead point as empty vector
        vector<double> lookAheadPoint = {0.0};
        lookAheadPoint = {};

        //Calculate distance between closest point and current robot position
        double smallestDistance = sqrt(pow((pointsList[closestPoint][0] - x), 2) + pow((pointsList[closestPoint][1] - y), 2));

        //Traverse through every point to find the closest point to the robot
        //For loop starts at closestPoint+1 to avoid traveling backwards
        for (int i = closestPoint + 1; i < pointsList.size(); i++)
        {

            //Calculates distance between current robot and each point after closest point
            double newDistance = sqrt(pow((pointsList[i][0] - x), 2) + pow((pointsList[i][1] - y), 2));

            //If the new distance is smaller than the smallest distance, replace smallest distance value with the new distance
            if (smallestDistance > newDistance)
            {
                smallestDistance = newDistance;

                //Change closest point to the new closest point
                closestPoint = i;
            }
        }

        //Calculate lookahead point if the last point is not within the default search radius
        if (closestPoint < pointsList.size() - 1 - lookAheadPointsNum)
        {
            lookAheadPoint = findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum, spacing);
        }

        //Use last point as lookahead point if the last point is within the default search radius
        else
        {
            lookAheadPoint = pointsList[pointsList.size() - 1];
        }

        //Exits loop if lookahead point and closest point align with the last point of the path
        if (lookAheadPoint[0] == pointsList[pointsList.size() - 1][0] && lookAheadPoint[1] == pointsList[pointsList.size() - 1][1] && (closestPoint == pointsList.size() - 1))
        {
            break;
        }

        //Calculate curvature between current position and lookahead point
        double curvature = findCurvature(lookAheadPoint, x, y, Kc);

        //Gets target left wheel speed, right wheel speed, velocity, and acceleration
        velocities = findVelocities(curvature, trackWidth, velList[closestPoint], maxAccel, velocities[2]);

        //Calculate feedforward and feedbackward values for the left and right wheels
        double leftFF = Kv * velocities[0] + Ka * (velocities[3]);
        double rightFF = Kv * velocities[1] + Ka * (velocities[3]);
        double leftFB = Kp * (velocities[0] - (-1.0 * convertToMeters(leftFrontMotor.get_actual_velocity() + -1.0 * leftBackMotor.get_actual_velocity()) / 2.0));
        double rightFB = Kp * (velocities[1] - (-1.0 * convertToMeters(rightFrontMotor.get_actual_velocity() + -1.0 * rightBackMotor.get_actual_velocity()) / 2.0));

        //Calculates motor velocities and moves the motors based on the feedforward and feedbackward values
        leftFrontMotor = -1.0 * convertToRPM(leftFF + leftFB) * 127.0 / 200;
        leftBackMotor = -1.0 * convertToRPM(leftFF + leftFB) * 127.0 / 200;
        rightFrontMotor = -1.0 * convertToRPM(rightFF + rightFB) * 127.0 / 200;
        rightBackMotor = -1.0 * convertToRPM(rightFF + rightFB) * 127.0 / 200;

        pros::delay(10);
    }

    //Stops all motors once robot reaches the endpoint
    leftFrontMotor = 0;
    leftBackMotor = 0;
    rightFrontMotor = 0;
    rightBackMotor = 0;
}

/**
 * Strafes left using pure pursuit algorithm
 * 
 * Parameters:
 * initPoints: list of all points in motion
 * spacing: distance between points in inches
 * smoothVal1: value 1 for smoothing (should be around 1 - smoothVal2)
 * smoothVal2: value 2 for smoothing (should be a value between 0.75 and 0.98)
 * smoothTolerance: acceptable tolerance for smoothing (should be around 0.001)
 * maxVelocity: maximum speed robot is allowed to reach during movement in m/s
 * maxAccel: maximum acceleration robot is allowed to reach during movement in m/s^2
 * turnConstant: turn constant (should be between 1.0 and 5.0)
 * lookAheadPointsNum: number of points to look ahead
 * trackWidth: width from left wheels to right wheels on robot in inches (due to turning scrub might be higher than actual width)
 * Kv: velocity constant (should be around 1/maxVelocity)
 * Ka: acceleration constant (should be around 0.002)
 * Kp: proportional constant (starts at 0.01, increasing will make velocities more accurate but more jittery)
 * Kc: curvature constant
 */
void ppMoveLeft(vector<vector<double>> initPoints, double spacing, double smoothVal1, double smoothVal2, double smoothTolerance, double maxVelocity, double maxAccel, double turnConstant, int lookAheadPointsNum, double trackWidth, double Kv, double Ka, double Kp, double Kc)
{

    //Initialize points list as an empty vector
    vector<vector<double>> pointsList = {{0.0}};
    pointsList = {};

    //Invalid call if no points are defined
    if (initPoints.size() == 0)
    {
        return;
    }

    //Generates path from current robot position to provided coordinate
    else if (initPoints.size() == 1)
    {
        pointsList = generateLinearPath(position.getPosition()[0], position.getPosition()[1], initPoints[0][0], initPoints[0][1], spacing);
    }

    //Generates path between each pair of consecutive points
    else
    {
        pointsList = generateLinearPath(initPoints[0][0], initPoints[0][1], initPoints[1][0], initPoints[1][1], spacing);
        if (initPoints.size() > 2)
        {
            for (int i = 1; i < initPoints.size() - 1; i++)
            {
                vector<vector<double>> pointsList2 = generateLinearPath(initPoints[i][0], initPoints[i][1], initPoints[i + 1][0], initPoints[i + 1][1], spacing);

                //Inserts each subsequent list at the end of the original
                pointsList.insert(pointsList.end(), pointsList2.begin(), pointsList2.end());
            }

            //Smooths entire points list
            pointsList = smooth(pointsList, smoothVal1, smoothVal2, smoothTolerance);
        }
    }

    //Calculate curvature along every point on the path
    vector<double> curveList = calculateCurve(pointsList);

    //Calculate velocity along every point on the path
    vector<double> velList = calculateVelocity(pointsList, curveList, maxVelocity, maxAccel, turnConstant);

    //Closest point starts as the second point in the list
    int closestPoint = 1;

    //Robot starts at rest with a velocity of 0.0 on each wheel
    vector<double> velocities = {0.0, 0.0};

    //Moves the robot until final position is reached
    while (true)
    {
        //Pulls the current robot coordinates
        double x = position.getPosition()[0];
        double y = position.getPosition()[1];

        //Initialize lookahead point as empty vector
        vector<double> lookAheadPoint = {0.0};
        lookAheadPoint = {};

        //Calculate distance between closest point and current robot position
        double smallestDistance = sqrt(pow((pointsList[closestPoint][0] - x), 2) + pow((pointsList[closestPoint][1] - y), 2));

        //Traverse through every point to find the closest point to the robot
        //For loop starts at closestPoint+1 to avoid traveling backwards
        for (int i = closestPoint + 1; i < pointsList.size(); i++)
        {
            //Calculates distance between current robot and each point after closest point
            double newDistance = sqrt(pow((pointsList[i][0] - x), 2) + pow((pointsList[i][1] - y), 2));

            //If the new distance is smaller than the smallest distance, replace smallest distance value with the new distance
            if (smallestDistance > newDistance)
            {
                smallestDistance = newDistance;

                //Change closest point to the new closest point
                closestPoint = i;
            }
        }

        //Calculate lookahead point if the last point is not within the default search radius
        if (closestPoint < pointsList.size() - 1 - lookAheadPointsNum)
        {
            lookAheadPoint = findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum, spacing);
        }

        //Use last point as lookahead point if the last point is within the default search radius
        else
        {
            lookAheadPoint = pointsList[pointsList.size() - 1];
        }

        //Exits loop if lookahead point and closest point align with the last point of the path
        if (lookAheadPoint[0] == pointsList[pointsList.size() - 1][0] && lookAheadPoint[1] == pointsList[pointsList.size() - 1][1] && (closestPoint == pointsList.size() - 1))
        {
            break;
        }

        //Calculate curvature between current position and lookahead point
        double curvature = findCurvatureLeft(lookAheadPoint, x, y, Kc);

        //Gets target left wheel speed, right wheel speed, velocity, and acceleration
        velocities = findVelocities(curvature, trackWidth, velList[closestPoint], maxAccel, velocities[2]);

        //Calculate feedforward and feedbackward values for the left and right wheels
        double leftFF = Kv * velocities[0] + Ka * (velocities[3]);
        double rightFF = Kv * velocities[1] + Ka * (velocities[3]);
        double leftFB = Kp * (velocities[0] - (convertToMeters(leftFrontMotor.get_actual_velocity() + leftBackMotor.get_actual_velocity()) / 2.0));
        double rightFB = Kp * (velocities[1] - (convertToMeters(rightFrontMotor.get_actual_velocity() + rightBackMotor.get_actual_velocity()) / 2.0));

        //Calculates motor velocities and moves the motors based on the feedforward and feedbackward values
        leftFrontMotor = -1 * convertToRPM(leftFF + leftFB) * 127.0 / 200;
        leftBackMotor = convertToRPM(leftFF + leftFB) * 127.0 / 200;
        rightFrontMotor = convertToRPM(rightFF + rightFB) * 127.0 / 200;
        rightBackMotor = -1 * convertToRPM(rightFF + rightFB) * 127.0 / 200;

        pros::delay(10);
    }

    //Stops all motors once robot reaches the endpoint
    leftFrontMotor = 0;
    leftBackMotor = 0;
    rightFrontMotor = 0;
    rightBackMotor = 0;
}

/**
 * Strafes right using pure pursuit algorithm
 * 
 * Parameters:
 * initPoints: list of all points in motion
 * spacing: distance between points in inches
 * smoothVal1: value 1 for smoothing (should be around 1 - smoothVal2)
 * smoothVal2: value 2 for smoothing (should be a value between 0.75 and 0.98)
 * smoothTolerance: acceptable tolerance for smoothing (should be around 0.001)
 * maxVelocity: maximum speed robot is allowed to reach during movement in m/s
 * maxAccel: maximum acceleration robot is allowed to reach during movement in m/s^2
 * turnConstant: turn constant (should be between 1.0 and 5.0)
 * lookAheadPointsNum: number of points to look ahead
 * trackWidth: width from left wheels to right wheels on robot in inches (due to turning scrub might be higher than actual width)
 * Kv: velocity constant (should be around 1/maxVelocity)
 * Ka: acceleration constant (should be around 0.002)
 * Kp: proportional constant (starts at 0.01, increasing will make velocities more accurate but more jittery)
 * Kc: curvature constant
 */
void ppMoveRight(vector<vector<double>> initPoints, double spacing, double smoothVal1, double smoothVal2, double smoothTolerance, double maxVelocity, double maxAccel, double turnConstant, int lookAheadPointsNum, double trackWidth, double Kv, double Ka, double Kp, double Kc)
{

    //Initialize points list as an empty vector
    vector<vector<double>> pointsList = {{0.0}};
    pointsList = {};

    //Invalid call if no points are defined
    if (initPoints.size() == 0)
    {
        return;
    }

    //Generates path from current robot position to provided coordinate
    else if (initPoints.size() == 1)
    {
        pointsList = generateLinearPath(position.getPosition()[0], position.getPosition()[1], initPoints[0][0], initPoints[0][1], spacing);
    }

    //Generates path between each pair of consecutive points
    else
    {
        pointsList = generateLinearPath(initPoints[0][0], initPoints[0][1], initPoints[1][0], initPoints[1][1], spacing);
        if (initPoints.size() > 2)
        {
            for (int i = 1; i < initPoints.size() - 1; i++)
            {
                vector<vector<double>> pointsList2 = generateLinearPath(initPoints[i][0], initPoints[i][1], initPoints[i + 1][0], initPoints[i + 1][1], spacing);
                
                //Inserts each subsequent list at the end of the original
                pointsList.insert(pointsList.end(), pointsList2.begin(), pointsList2.end());
            }

            //Smooths entire points list
            pointsList = smooth(pointsList, smoothVal1, smoothVal2, smoothTolerance);
        }
    }
    
    //Calculate curvature along every point on the path
    vector<double> curveList = calculateCurve(pointsList);

    //Calculate velocity along every point on the path
    vector<double> velList = calculateVelocity(pointsList, curveList, maxVelocity, maxAccel, turnConstant);

    //Closest point starts as the second point in the list
    int closestPoint = 1;
    
    //Robot starts at rest with a velocity of 0.0 on each wheel
    vector<double> velocities = {0.0, 0.0};

    //Moves the robot until final position is reached
    while (true)
    {   
        //Pulls the current robot coordinates
        double x = position.getPosition()[0];
        double y = position.getPosition()[1];

        //Initialize lookahead point as empty vector
        vector<double> lookAheadPoint = {0.0};
        lookAheadPoint = {};

        //Calculate distance between closest point and current robot position
        double smallestDistance = sqrt(pow((pointsList[closestPoint][0] - x), 2) + pow((pointsList[closestPoint][1] - y), 2));
        
        //Traverse through every point to find the closest point to the robot
        //For loop starts at closestPoint+1 to avoid traveling backwards
        for (int i = closestPoint + 1; i < pointsList.size(); i++)
        {   
            //Calculates distance between current robot and each point after closest point
            double newDistance = sqrt(pow((pointsList[i][0] - x), 2) + pow((pointsList[i][1] - y), 2));
            
            //If the new distance is smaller than the smallest distance, replace smallest distance value with the new distance
            if (smallestDistance > newDistance)
            {
                smallestDistance = newDistance;

                //Change closest point to the new closest point
                closestPoint = i;
            }
        }

        //Calculate lookahead point if the last point is not within the default search radius
        if (closestPoint < pointsList.size() - 1 - lookAheadPointsNum)
        {
            lookAheadPoint = findLookAheadPoint(x, y, pointsList, closestPoint, lookAheadPointsNum, spacing);
        }

        //Use last point as lookahead point if the last point is within the default search radius
        else
        {
            lookAheadPoint = pointsList[pointsList.size() - 1];
        }

        //Exits loop if lookahead point and closest point align with the last point of the path
        if (lookAheadPoint[0] == pointsList[pointsList.size() - 1][0] && lookAheadPoint[1] == pointsList[pointsList.size() - 1][1] && (closestPoint == pointsList.size() - 1))
        {
            break;
        }

        //Calculate curvature between current position and lookahead point
        double curvature = findCurvatureRight(lookAheadPoint, x, y, Kc);

        //Gets target left wheel speed, right wheel speed, velocity, and acceleration
        velocities = findVelocities(curvature, trackWidth, velList[closestPoint], maxAccel, velocities[2]);

        //Calculate feedforward and feedbackward values for the left and right wheels
        double leftFF = Kv * velocities[0] + Ka * (velocities[3]);
        double rightFF = Kv * velocities[1] + Ka * (velocities[3]);
        double leftFB = Kp * (velocities[0] - (convertToMeters(leftFrontMotor.get_actual_velocity() + leftBackMotor.get_actual_velocity()) / 2.0));
        double rightFB = Kp * (velocities[1] - (convertToMeters(rightFrontMotor.get_actual_velocity() + rightBackMotor.get_actual_velocity()) / 2.0));

        //Calculates motor velocities and moves the motors based on the feedforward and feedbackward values
        leftFrontMotor = convertToRPM(leftFF + leftFB) * 127.0 / 200;
        leftBackMotor = -1 * convertToRPM(leftFF + leftFB) * 127.0 / 200;
        rightFrontMotor = -1 * convertToRPM(rightFF + rightFB) * 127.0 / 200;
        rightBackMotor = convertToRPM(rightFF + rightFB) * 127.0 / 200;

        pros::delay(10);
    }

    //Stops all motors once robot reaches the endpoint
    leftFrontMotor = 0;
    leftBackMotor = 0;
    rightFrontMotor = 0;
    rightBackMotor = 0;
}